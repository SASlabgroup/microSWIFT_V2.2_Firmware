
Lengthy list of TODOs:

****************************************************************************************************
Busses
****
- SPI1:= 	 	Core SPI bus
       		 	-> RTC
       		
- I2C1:=	 	Core I2C bus
			 	-> Light Sensor
			 	-> Turbidity
			 	-> Temperature
			
- UART4:=	 	Core UART
			 	-> Iridium
		 	
- UART5:=	 	Core UART
			 	-> CT
			
- LPUART1:=	 	Core UART
			 	-> GNSS
			
- USART6:=	 	Logger UART

- SDMMC1:= 		SD card non-volatile

- EXPANSION:= 	I2C2, I2C3, SPI2, SPI3, USART2, USART3

****************************************************************************************************
General
*******

[ ] Make a common return code for EVERYTHING.
	[ ] Ensure all functions return an int32_t for this and have a single enum definition for return codes
[ ] Try using the RTC as the LSE clock source.
	[ ] Will require a call to enable clock out on RTC in main immediately after HAL_Init and before clock/pwr config
[x] Check static stack usage and adjust threead stack size accordingly
[x] Make generic green/red led on/off functions
    [x] Need to move the pins and use throughole LEDs for the prototype
[x] Finish implementation of watchdog
[x] Check all init calls in startup procedure to make sure bus peripheral is starting properly
[ ] Redo all GPIO bare pin calls -- FET pins, etc -- to use GPIO functions in gpio.c. Make sure to
    pass in GPIO pin/port definitions and include them in the structs.
[x] Figure out how to disable watchdog in debug mode
	[x] Likely just adjust the watchdog period to be very long
[ ] Make sure everything sticks to the principle that there are no infinite loops
	[ ] Need to insert some timers in various places, such as a timer for the full sample, process, transmit scheme
	    and initialization of sensors
[x] Ditch watchdog hour timer and all that baggage
[x] Modify linker script -- add external memory if necessary
	[x] Added section for SRAM2 and moved waves memory pool and a few other small things to RAM1
[x] Make a thread to handle UART console port comms... Will use USART 6, 115200 baud, 8N1
[ ] Ensure all possible error conditions (including interrupts, default handler, etc) will not
    result in a forever loop -- all unexpected conditions should software reset.    
    
****************************************************************************************************
Control
*******
[ ] Figure out the control flow if GNSS is unable to get a fix'
	[ ] 
[x] Figure out how to identify first time power on and subsequent power on.
[x] Remove all thread control and sys reset calls from threads other than control_thread
[x] Implement Error_Handler() that checks error flags and acts accordingly
	[x] This is implemented as control.monitor_and_handle_errors()
[ ] Implement subsequent power on fasttrack
	[ ] Need to make sure everything is still tested. Found a case where the light sensor ran astray
	    in a subsequent window.
[x] Consider wrapping the initialization of north, east, down arrays into mem_replacements.c and
    provide get/set functions for passing to GNSS and waves
[ ] Implement shut_it_all_down(), enter_shutdown_mode(), etc
	[ ] Ensure all modes result in soft-shutdown
[x] End of cycle now becomes setting an alarm, soft shutting down everything, and entering
    shutdown mode
[ ] Figure out how to keep the modem off during standby mode.
	[ ] Will need to configure pull resistors in standby like we do with the RTC Int
	[ ] Make sure this works with both v3.D and v3.F modems

****************************************************************************************************
RTC
***
[ ] Ensure the timestamps are setup to overwrite -- this needs to be added to 

****************************************************************************************************
GNSS
****

[x] Move buffers to inside GNSS struct
	[x] Still as pointers in the struct, but the buffers live in the GNSS thread and are passed from there
[x] Give GNSS a FIFO for messages
	[x] not needed
[x] Rework DMA transfers
    [x] Circular mode shouldn't start until the linked list is set up -- remove the DMA stop/ abort
        calls early on, but test to make sure this is correct
    [x] Clean up all the functions for switching to circular
    [x] Study this: 
    https://github.com/STMicroelectronics/STM32CubeU5/tree/main/Projects/NUCLEO-U575ZI-Q/Examples/UART/UART_ReceptionToIdle_CircularDMA
    [x] The newly added linked list structure and LPDMA MX functions should work or be close to
        correct
[x] Improve GNSS config -- find a better way to identify UART idle conditions, etc
[x] Use a TX_TIMER instead of a hardware timer
[x] Generalize UART to a better degree
	[x] Only so much you can do with GNSS...
[x] Move the callback function for setting up DMA to inside gnss.c
[ ] See if initialization and configuration can be improved -- there has to be a better way to
    get the config done
    [ ] Just added a thing to power cycle the GNSS every 5 failed retries. We'll see if that fixes the intermittent config failure.
[ ] Reorg functions and clean up comments

****************************************************************************************************
Iridium
*******

[ ] When the thread is resumed, first check if there is anything to send before wasting energy charging the caps
[x] Move buffers to inside Iridium struct
[x] Use a TX_TIMER instead of a hardware timer
[x] Switch UART over to using a generic uart driver
[x] Reorg functions and clean up comments

****************************************************************************************************
CT
**

[ ] Move buffers to inside CT struct
[ ] Switch over to generic UART driver

****************************************************************************************************
Termperature
************

[ ] Move buffers to inside Temperature struct
[ ] Rework I2C driver

****************************************************************************************************
Light
*****

[ ] Rework I2C and figure out how to share bus
	[ ] generic_i2c_driver is a start... The core I2C bus might well be shared between several sensors
[ ] Give 2 timestamps to the light thread which can be used for tracking min/max for the clear channel

****************************************************************************************************
ThreadX
*******

[ ] Figure out the required main memory pool size
	[ ] Currently good, but will likely need to increase size soon
[x] Find a new way to identify subsequent windows since we will go into shutdown mode after the end
    of the sample window
[x] Change all non-threadx objects to static allocation -- remove from App_ThreadX_Init()
	[ ] Threads now own object that only they should modify/ control
[x] Make a control thread
    [x] Move startup and end-of-cycle thread functions inside
    [x] make event loop handler type deal to look for error flags or something
[ ] Fill out Tx low power functions and see if things work with Stop1 mode
    [ ] Non-critical, if it makes everything fall apart, ditch it
[x] Figure out how to get threads running concurrently: i.e. CT sampling while GNSS wrapping up
    [x] Should be easy with control thread
    
****************************************************************************************************
Logger
******

[ ] Make a utility to pass all logs down to FileX
[x] Initialize in control, set the configuration flag if it is enabled
	[x] It has its own thread and event loop
[x] logger functions first check if it is enabled, if not, return immediately
[x] must run in a server style thread...
